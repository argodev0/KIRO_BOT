input {
  beats {
    port => 5044
  }
  
  tcp {
    port => 5000
    codec => json_lines
  }
  
  udp {
    port => 5000
    codec => json_lines
  }
  
  http {
    port => 8080
    codec => json
  }
}

filter {
  # Parse trading bot logs
  if [service] == "trading-bot" {
    # Parse timestamp
    date {
      match => [ "timestamp", "ISO8601" ]
    }
    
    # Extract trading-specific fields
    if [message] =~ /Trade executed/ {
      grok {
        match => { "message" => "Trade executed: %{WORD:action} %{NUMBER:quantity} %{WORD:symbol} at %{NUMBER:price}" }
      }
      mutate {
        add_tag => [ "trade_execution" ]
        convert => { "quantity" => "float" }
        convert => { "price" => "float" }
      }
    }
    
    # Extract signal generation
    if [message] =~ /Signal generated/ {
      grok {
        match => { "message" => "Signal generated: %{WORD:direction} %{WORD:symbol} confidence %{NUMBER:confidence}" }
      }
      mutate {
        add_tag => [ "signal_generation" ]
        convert => { "confidence" => "float" }
      }
    }
    
    # Extract error information
    if [level] == "error" {
      mutate {
        add_tag => [ "error" ]
      }
      
      # Parse stack traces
      if [stack] {
        mutate {
          add_field => { "has_stack_trace" => true }
        }
      }
    }
    
    # Extract performance metrics
    if [message] =~ /Performance/ {
      grok {
        match => { "message" => "Performance: %{WORD:metric} %{NUMBER:value} %{WORD:unit}" }
      }
      mutate {
        add_tag => [ "performance" ]
        convert => { "value" => "float" }
      }
    }
  }
  
  # Parse system logs
  if [service] == "system" {
    mutate {
      add_tag => [ "system" ]
    }
  }
  
  # Parse exchange logs
  if [exchange] {
    mutate {
      add_tag => [ "exchange", "[exchange]" ]
    }
    
    # Parse API errors
    if [message] =~ /API error/ {
      grok {
        match => { "message" => "API error: %{NUMBER:error_code} %{GREEDYDATA:error_message}" }
      }
      mutate {
        add_tag => [ "api_error" ]
        convert => { "error_code" => "integer" }
      }
    }
  }
  
  # Add geolocation for IP addresses
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
  
  # Normalize log levels
  mutate {
    lowercase => [ "level" ]
  }
  
  # Add processing timestamp
  mutate {
    add_field => { "processed_at" => "%{@timestamp}" }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "trading-bot-logs-%{+YYYY.MM.dd}"
    template_name => "trading-bot"
    template => "/usr/share/logstash/templates/trading-bot-template.json"
    template_overwrite => true
  }
  
  # Output errors to separate index
  if "error" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "trading-bot-errors-%{+YYYY.MM.dd}"
    }
  }
  
  # Output trading events to separate index
  if "trade_execution" in [tags] or "signal_generation" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "trading-bot-events-%{+YYYY.MM.dd}"
    }
  }
  
  # Debug output (remove in production)
  stdout {
    codec => rubydebug
  }
}